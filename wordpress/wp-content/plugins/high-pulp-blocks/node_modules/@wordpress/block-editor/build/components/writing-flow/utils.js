"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPasteBlocks = getPasteBlocks;
exports.setClipboardBlocks = setClipboardBlocks;
var _dom = require("@wordpress/dom");
var _blocks2 = require("@wordpress/blocks");
var _pasting = require("../../utils/pasting");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Sets the clipboard data for the provided blocks, with both HTML and plain
 * text representations.
 *
 * @param {ClipboardEvent} event  Clipboard event.
 * @param {WPBlock[]}      blocks Blocks to set as clipboard data.
 */
function setClipboardBlocks(event, blocks) {
  let _blocks = blocks;
  const wrapperBlockName = event.clipboardData.getData('__unstableWrapperBlockName');
  if (wrapperBlockName) {
    _blocks = (0, _blocks2.createBlock)(wrapperBlockName, JSON.parse(event.clipboardData.getData('__unstableWrapperBlockAttributes')), _blocks);
  }
  const serialized = (0, _blocks2.serialize)(_blocks);
  event.clipboardData.setData('text/plain', toPlainText(serialized));
  event.clipboardData.setData('text/html', serialized);
}

/**
 * Returns the blocks to be pasted from the clipboard event.
 *
 * @param {ClipboardEvent} event                    The clipboard event.
 * @param {boolean}        canUserUseUnfilteredHTML Whether the user can or can't post unfiltered HTML.
 * @return {Array|string} A list of blocks or a string, depending on `handlerMode`.
 */
function getPasteBlocks(event, canUserUseUnfilteredHTML) {
  const {
    plainText,
    html,
    files
  } = (0, _pasting.getPasteEventData)(event);
  let blocks = [];
  if (files.length) {
    const fromTransforms = (0, _blocks2.getBlockTransforms)('from');
    blocks = files.reduce((accumulator, file) => {
      const transformation = (0, _blocks2.findTransform)(fromTransforms, transform => transform.type === 'files' && transform.isMatch([file]));
      if (transformation) {
        accumulator.push(transformation.transform([file]));
      }
      return accumulator;
    }, []).flat();
  } else {
    blocks = (0, _blocks2.pasteHandler)({
      HTML: html,
      plainText,
      mode: 'BLOCKS',
      canUserUseUnfilteredHTML
    });
  }
  return blocks;
}

/**
 * Given a string of HTML representing serialized blocks, returns the plain
 * text extracted after stripping the HTML of any tags and fixing line breaks.
 *
 * @param {string} html Serialized blocks.
 * @return {string} The plain-text content with any html removed.
 */
function toPlainText(html) {
  // Manually handle BR tags as line breaks prior to `stripHTML` call
  html = html.replace(/<br>/g, '\n');
  const plainText = (0, _dom.__unstableStripHTML)(html).trim();

  // Merge any consecutive line breaks
  return plainText.replace(/\n\n+/g, '\n\n');
}
//# sourceMappingURL=utils.js.map