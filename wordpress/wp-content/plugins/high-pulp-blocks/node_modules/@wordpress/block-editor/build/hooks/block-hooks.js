"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = require("react");
var _i18n = require("@wordpress/i18n");
var _element = require("@wordpress/element");
var _components = require("@wordpress/components");
var _blocks = require("@wordpress/blocks");
var _data = require("@wordpress/data");
var _components2 = require("../components");
var _store = require("../store");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const EMPTY_OBJECT = {};
function BlockHooksControlPure({
  name,
  clientId
}) {
  const blockTypes = (0, _data.useSelect)(select => select(_blocks.store).getBlockTypes(), []);
  const hookedBlocksForCurrentBlock = (0, _element.useMemo)(() => blockTypes?.filter(({
    blockHooks
  }) => blockHooks && name in blockHooks), [blockTypes, name]);
  const {
    blockIndex,
    rootClientId,
    innerBlocksLength
  } = (0, _data.useSelect)(select => {
    const {
      getBlock,
      getBlockIndex,
      getBlockRootClientId
    } = select(_store.store);
    return {
      blockIndex: getBlockIndex(clientId),
      innerBlocksLength: getBlock(clientId)?.innerBlocks?.length,
      rootClientId: getBlockRootClientId(clientId)
    };
  }, [clientId]);
  const hookedBlockClientIds = (0, _data.useSelect)(select => {
    const {
      getBlock,
      getGlobalBlockCount
    } = select(_store.store);
    const _hookedBlockClientIds = hookedBlocksForCurrentBlock.reduce((clientIds, block) => {
      // If the block doesn't exist anywhere in the block tree,
      // we know that we have to set the toggle to disabled.
      if (getGlobalBlockCount(block.name) === 0) {
        return clientIds;
      }
      const relativePosition = block?.blockHooks?.[name];
      let candidates;
      switch (relativePosition) {
        case 'before':
        case 'after':
          // Any of the current block's siblings (with the right block type) qualifies
          // as a hooked block (inserted `before` or `after` the current one), as the block
          // might've been automatically inserted and then moved around a bit by the user.
          candidates = getBlock(rootClientId)?.innerBlocks;
          break;
        case 'first_child':
        case 'last_child':
          // Any of the current block's child blocks (with the right block type) qualifies
          // as a hooked first or last child block, as the block might've been automatically
          // inserted and then moved around a bit by the user.
          candidates = getBlock(clientId).innerBlocks;
          break;
      }
      const hookedBlock = candidates?.find(candidate => candidate.name === block.name);

      // If the block exists in the designated location, we consider it hooked
      // and show the toggle as enabled.
      if (hookedBlock) {
        return {
          ...clientIds,
          [block.name]: hookedBlock.clientId
        };
      }

      // If no hooked block was found in any of its designated locations,
      // we set the toggle to disabled.
      return clientIds;
    }, {});
    if (Object.values(_hookedBlockClientIds).length > 0) {
      return _hookedBlockClientIds;
    }
    return EMPTY_OBJECT;
  }, [hookedBlocksForCurrentBlock, name, clientId, rootClientId]);
  const {
    insertBlock,
    removeBlock
  } = (0, _data.useDispatch)(_store.store);
  if (!hookedBlocksForCurrentBlock.length) {
    return null;
  }

  // Group by block namespace (i.e. prefix before the slash).
  const groupedHookedBlocks = hookedBlocksForCurrentBlock.reduce((groups, block) => {
    const [namespace] = block.name.split('/');
    if (!groups[namespace]) {
      groups[namespace] = [];
    }
    groups[namespace].push(block);
    return groups;
  }, {});
  const insertBlockIntoDesignatedLocation = (block, relativePosition) => {
    switch (relativePosition) {
      case 'before':
      case 'after':
        insertBlock(block, relativePosition === 'after' ? blockIndex + 1 : blockIndex, rootClientId,
        // Insert as a child of the current block's parent
        false);
        break;
      case 'first_child':
      case 'last_child':
        insertBlock(block,
        // TODO: It'd be great if insertBlock() would accept negative indices for insertion.
        relativePosition === 'first_child' ? 0 : innerBlocksLength, clientId,
        // Insert as a child of the current block.
        false);
        break;
    }
  };
  return (0, _react.createElement)(_components2.InspectorControls, null, (0, _react.createElement)(_components.PanelBody, {
    className: "block-editor-hooks__block-hooks",
    title: (0, _i18n.__)('Plugins'),
    initialOpen: true
  }, Object.keys(groupedHookedBlocks).map(vendor => {
    return (0, _react.createElement)(_element.Fragment, {
      key: vendor
    }, (0, _react.createElement)("h3", null, vendor), groupedHookedBlocks[vendor].map(block => {
      const checked = (block.name in hookedBlockClientIds);
      return (0, _react.createElement)(_components.ToggleControl, {
        checked: checked,
        key: block.title,
        label: (0, _react.createElement)(_components.__experimentalHStack, {
          justify: "flex-start"
        }, (0, _react.createElement)(_components2.BlockIcon, {
          icon: block.icon
        }), (0, _react.createElement)("span", null, block.title)),
        onChange: () => {
          if (!checked) {
            // Create and insert block.
            const relativePosition = block.blockHooks[name];
            insertBlockIntoDesignatedLocation((0, _blocks.createBlock)(block.name), relativePosition);
            return;
          }

          // Remove block.
          removeBlock(hookedBlockClientIds[block.name], false);
        }
      });
    }));
  })));
}
var _default = exports.default = {
  edit: BlockHooksControlPure,
  hasSupport() {
    return true;
  }
};
//# sourceMappingURL=block-hooks.js.map